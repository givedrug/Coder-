# coder-notes
just a test!
test2

juestsag 

haha


huhu

good

关于mysql同步ck的不同方案对比：
因为ck的自身OLAP特征，对于update和delete的支持十分有限，当需要进行变更数据操作时，往往只能迂回解决：
方案一：mysql直接同步到ck表
insert->直接执行
update->转为异步alter update语句
delte->转为异步alter delete语句

这种方案的优点是改造比较简单，只需要稍微改变一下sql的语句就可以实现功能。
缺点是，异步操作会消耗较多的性能，切多次异步操作同时进行时，数据的正确性存疑。

方案二：mysql先同步到明细表，明细表通过物化视图到最终表
步骤一，同步明细表
insert->直接执行，带时间戳
update->转为insert执行，带时间戳
delete->转为insert执行，带时间戳，带删除标记
步骤二，转化为物化视图表（ReplicatedUniqueMergeTree引擎）
通过对时间戳字段排序，主键相同的取最新一行数据（删除数据也会取到）
步骤三，查询时，筛选出不带删除标记的数据

这种方案优点是，去除了所有的异步操作，保证了性能
缺点是，配置和使用都较为复杂，而且时间戳字段只能精确到秒，所以同一秒内的多次更新操作，可能导致数据乱序，造成数据错误

总结：对于大数据量的表频繁变更的场景，频繁异步操作的性能消耗将使得ck不可用。
所以同步方案由一改为二，对于方案二可能造成数据错误的问题，他们自己在业务处理时代码限制来保证。
后续，将会把adapter对于ck的同步逻辑修改为方案二的方式，等改造完，再评估使用效果。
