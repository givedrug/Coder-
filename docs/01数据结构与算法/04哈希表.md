## 知识点

### HashSet与HashMap设计

首先设计一个考虑HashSet，主要考虑如下问题：

**哈希函数**：能够将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上。

**冲突处理**：由于不同元素可能映射到相同的整数值，因此需要在整数值出现「冲突」时，需要进行冲突处理。总的来说，有以下几种策略解决冲突：

- 链地址法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。

![](assets/04哈希表/链地址法.png)

- 开放地址法：当发现哈希值 $h$ 处产生冲突时，根据某种策略，从 $h$ 出发找到下一个不冲突的位置。例如，一种最简单的策略是，不断地检查 $h+1,h+2,h+3,…$ 这些整数对应的位置。
- 再哈希法：当发现哈希冲突后，使用另一个哈希函数产生一个新的地址。

这里以取整函数作为哈希函数，并使用链地址法来实现一个简易的HashSet：

```java
class MyHashSet {
    private static final int BASE = 769;
    private LinkedList[] data;

    /**
     * Initialize your data structure here.
     */
    public MyHashSet() {
        data = new LinkedList[BASE];
        for (int i = 0; i < BASE; ++i) {
            data[i] = new LinkedList<Integer>();
        }
    }

    public void add(int key) {
        int h = hash(key);
        for (Object element : data[h]) {
            if ((Integer) element == key) {
                return;
            }
        }
        data[h].offerLast(key);
    }

    public void remove(int key) {
        int h = hash(key);
        for (Object element : data[h]) {
            if ((Integer) element == key) {
                data[h].remove(element);
                return;
            }
        }
    }

    /**
     * Returns true if this set contains the specified element
     */
    public boolean contains(int key) {
        int h = hash(key);
        for (Object element : data[h]) {
            if ((Integer) element == key) {
                return true;
            }
        }
        return false;
    }

    private int hash(int key) {
        return key % BASE;
    }
}
```

- 时间复杂度：$O(\frac{n}{b})$ 其中 $n$ 是元素个数， $b$ 是链表节点个数
- 空间复杂度：$O(n+b)$

可以考虑从如下方向来优化这个HashSet：
1. 采用更优的哈希函数，比如java8中默认的扰动函数
2. 将链地址法中的链表改为树，比如java8中如果链表长度大于8，将会转为红黑树来存储
3. 扩容策略，当元素个数变大，冲突会显著增加，这时为了提升效率可以进行扩容，比如java8会将容量增加1倍
> **思考：为什么哈希函数在取整操作时，需要选择一个质数呢？**
> 
> 在初等数学中有一个基本定理，任意一个大于1的自然数，要么本身就是质数，要么可以分解为几个质数之积，这种分解本身，具有唯一性。
> 
> 数字的因子越多，取模后冲突的可能性就越大。而素数的因子恰好只有1和其本身,就非常适合用于解决冲突。
> 
> 比如2,4,6,8,10,12这6个数，如果对6取余，得到2,4,0,2,4,0只会得到3种HASH值，6的因子有1,2,3,6。冲突会很多；如果对7取余，得到2,4,6,1,3,5得到6种HASH值，而7的因子只有1,7。（即使1的因子最小，但是在实际中并不用，因为mod1相当于不解决冲突。而初始化的的数组就会非常大。）
> 
> Hash的用途很多，我们在使用Ngnix做负载均衡的时候，同样用的也是Hash的方式。总的来说，要是数据分布均匀一些，在这种时候就可以考虑使用Hash的方式对数据进行处理。
> 
> 但凡事都有利弊，对于取整操作选择一个质数，虽然降低了取模时冲突的可能性，但Java8官方并没有使用质数，而是将默认值设置为16，并且扩容之后，依然是2的幂，这是为什么呢？主要有两点好处：
> 
> 1）计算hash值时，使用2的幂，可以直接通过取低位的固定位数的操作来计算，速度更快。比如计算26mod16，直接取11010(26)的后4位，1010(10)即为所得。
> 
> 2）在扩容时，需要对所有元素进行重新哈希，使用2的幂，可以使得一部分元素（均匀分布下是一半的元素），不需要移动。比如，1010(10)在数组长度为16时，取1010(10)的后4位，得到1010(10)，而在扩容后，长度变为32时，应取1010(10)的后5位，仍然得到1010(10)，不需要移动位置。而且，对于需要移动的元素，其下一个位置也容易通过位运算来计算，比如26mod16为1010(10)，26mod32为11010(26)，只需要在旧的哈希值前面补1即可。
>

接下来，考虑如何设计一个HashMap，和HashSet类似，只需要将存储的只由key改为一个key-value键值对即可：

```java
class MyHashMap {
    private class Pair {
        private int key;
        private int value;

        public Pair(int key, int value) {
            this.key = key;
            this.value = value;
        }

        public int getKey() {
            return key;
        }

        public int getValue() {
            return value;
        }

        public void setValue(int value) {
            this.value = value;
        }
    }

    private static final int BASE = 769;
    private LinkedList[] data;

    /**
     * Initialize your data structure here.
     */
    public MyHashMap() {
        data = new LinkedList[BASE];
        for (int i = 0; i < BASE; ++i) {
            data[i] = new LinkedList<Pair>();
        }
    }

    /**
     * value will always be non-negative.
     */
    public void put(int key, int value) {
        int h = hash(key);
        for (Object pair : data[h]) {
            if (((Pair) pair).getKey() == key) {
                ((Pair) pair).setValue(value);
                return;
            }
        }
        data[h].offerLast(new Pair(key, value));
    }

    /**
     * Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key
     */
    public int get(int key) {
        int h = hash(key);
        for (Object pair : data[h]) {
            if (((Pair) pair).getKey() == key) {
                return ((Pair) pair).getValue();
            }
        }
        return -1;
    }

    /**
     * Removes the mapping of the specified value key if this map contains a mapping for the key
     */
    public void remove(int key) {
        int h = hash(key);
        for (Object pair : data[h]) {
            if (((Pair) pair).getKey() == key) {
                data[h].remove(pair);
                return;
            }
        }
    }

    private int hash(int key) {
        return key % BASE;
    }
}
```

参考：
1. [leetcode题解：HashSet](https://leetcode.cn/problems/design-hashset/solutions/)
2. [leetcode题解：HashMap](https://leetcode.cn/problems/design-hashmap/solutions/)

### LRU缓存设计

**题目：**

请你设计并实现一个满足 LRU (Least Recently Used 最近最少使用)缓存约束的数据结构。

实现 LRUCache 类：
- LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存；
- int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回-1；
- void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该逐出 最久未使用的关键字。

注意：函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。

> **示例：**
> 
> 输入
> \["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"\]
> \[\[2\], \[1, 1\], \[2, 2\], \[1\], \[3, 3\], \[2\], \[4, 4\], \[1\], \[3\], \[4\]\]
> 
> 输出
> \[null, null, null, 1, null, -1, null, -1, 3, 4\]
> 
> 解释
> 
> LRUCache lRUCache = new LRUCache(2);
> 
> lRUCache.put(1, 1); // 缓存是 {1=1}
> 
> lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
> 
> lRUCache.get(1);    // 返回 1
> 
> lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
> 
> lRUCache.get(2);    // 返回 -1 (未找到)
> 
> lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
> 
> lRUCache.get(1);    // 返回 -1 (未找到)
> 
> lRUCache.get(3);    // 返回 3
> 
> lRUCache.get(4);    // 返回 4

思路：

代码：

参考：


### LFU缓存设计
todo

## 练习题目

**题目**
- LeetCode 36. Valid Sudoku 有效的数独
- LeetCode 49. Group Anagrams 字母异位词分组
- LeetCode 202. Happy Number 快乐数
- LeetCode 205. Isomorphic Strings 同构字符串
- LeetCode 287. Find the Duplicate Number 寻找重复数
- LeetCode 349. Intersection of Two Arrays 两个数组的交集
- LeetCode 350. Intersection of Two Arrays II 两个数组的交集 II
- LeetCode 387. First Unique Character in a String 字符串中的第一个唯一字符
- LeetCode 454. 4Sum II 四数相加 II
- LeetCode 705. Design HashSet 设计哈希集合
- LeetCode 706. Design HashMap 设计哈希映射
- （困难）LeetCode 146. LRU Cache LRU 缓存
- （困难）LeetCode 380. Insert Delete GetRandom O(1) O(1) 时间插入、删除和获取随机元素
- （困难）LeetCode 460. LFU Cache LFU 缓存

**思路**
- LeetCode 36. 
> 方法一：分别按行、按列、按九宫遍历
> 
> 复杂度：1（遍历次数为常数）
> 
> 方法二：官方解答中，也可以把三次遍历转为一次遍历，并同时记录三种条件下的重复情况
> 
> 复杂度：1（遍历次数为常数）
> 
- LeetCode 49. 
> 生成每个字符串的排序后字符串，通过hash表做映射
> 
> 复杂度：n\*m\*log(m)
> 
- LeetCode 202. 
> 方法一：使用HashSet
> 
> 复杂度：log(n)
> 
> 方法二：官方解答还提出可以使用快慢指针来实现，等价于找到链表是否有环
> 
> 复杂度：log(n)
> 
- LeetCode 205. 
> 保存两字符串的对应字符的映射关系，注意要保留相互两份映射
> 
> 复杂度：n
> 
- LeetCode 287. 
> 方法一：使用HashSet
> 
> 复杂度：时间n、空间n
> 
> 方法二：官方解答中提到了一种时间n、空间1的方法，双指针法。
> 
> 首先将数组构造成链表（必然有环）index->nums[index]
> 
> 0 1 2 3 4
> 
> 1 3 4 2 2
> 
> 链表为：0->1->3->2->4(->2成环)
> 
> 简单证明为什么一定成环，首先0作为起点，只会指向别的节点，不会有节点指向0，这样（除去0）index就有n个，而被指向的节点共有n+1个，所以必然有一个节点至少被从两个位置指向（包括自指向）
> 
> 注意：不一定只有一个环，但从0出发的一定能找到有且一个环，如下例子：
> 
> 0 1 2 3 4
> 
> 1 2 2 4 3
> 
> 链表为：0->1->2(->2自成环)
> 
> 3->4(->3成第二个环)
> 
> 这样构造出从0出发的一定有一个环的链表，且环入口就是重复元素，就可以使用快慢指针来找到了，而且这个链表并不一定要真正的构造出来，index和nums[index]的关系已经足够。
> 
> 复杂度：时间n、空间1
> 
- LeetCode 349. 
> 使用HashSet
> 
> 复杂度：n
> 
- LeetCode 350. 
> 使用HashMap，计数
> 
> 复杂度：n
> 
- LeetCode 387. 
> 使用map计数，还可以使用Ascii码数组计数，速度更快
> 
> 复杂度：n
> 
- LeetCode 454. 
> 分别计算数组1、2和数组3、4的所有和的统计结果map，然后遍历和为0的计数。另外，如果数组重复值多的话，还可以继续优化，先统计数字出现个数，再生成统计map
> 
> 复杂度：n^2
> 
- LeetCode 705. 
> 使用一个数组存数据，数组元素是一个链表表头，该链表下所有key的hash值相等。
> 
> 另外，这里只是给出一个最简单的hashSet实现，如果要进行优化，可以从下面几点考虑：
> 
> 1）hash函数，可以采用更优的散列函数。
> 
> 2）链表改为树，参考Java内置HashMap的实现。
> 
> 3）扩容机制，当元素个数过多时，可以对其进行扩容，降低hash冲突概率。
> 
> 复杂度：>1
> 
- LeetCode 706. 
> 与705相似
> 
> 复杂度：>1
> 
- （困难）LeetCode 146. 
> 方法一：通过双向链表（目的是保存先后顺序）表示LRU，但查询复杂度为n，所以增加一个辅助hash表，使得查询复杂度降为1
> 
> 复杂度：1
> 
> 方法二：还可以借助java提供的LinkedHashMap来实现，它本身就是通过list+hash结合实现的
> 
> 复杂度：1
> 
- （困难）LeetCode 380. 
> 使用一个HashMap，一个ArrayList
> 
> 复杂度：1
> 
- （困难）LeetCode 460. 
> map-list-map方案：
> 
> 首先建立一个hashmap，key是访问次数，value是一个linkedList，list内所有节点的访问次数是一样的，并按访问时间排序。
> 
> 然后再建立一个hashmap，key是输入数据的key，value是上述list的节点，为了方便定位某个具体key-value数据。
> 
> 最后再维护一个当前最小访问次数的变量，用户快速找到需要剔除的元素。
> 
> 复杂度：1
> 
